## 详解事务的ACID

事务的ACID大家都很熟悉的

A（Atomic）：原子性，表示一个事务在一个原子性操作中执行，一步到位。

C（Consistent）：一致性，表示一个事务的执行结束后，事务中的所有执行动作执行结果是一致的。要么全成功，要么全失败。

I（Isolated）：隔离性，并发执行的事务，各个事务之间无法看到对方的中间状态。

D（Durable）：持久性，事务完成后所改动的数据都会被持久化，即发生灾难性的毁灭后，也会通过日志，同步备份来重建数据。



大概理解了上面说的四个特性，原子性和一致性其实目的是一样的，就是保证一个事务的一次执行，执行结果要一直。隔离性我们专门有一篇文章去解读，今天我们主要分析一下在innodb存储引擎下Durable持久性是怎样实现保证的。



#### Durable持久性主要通过redolog和double write来保证实现。

比如我们的一个查询会先从buffer poll里面的缓存去查询，页缓存查不到数据了才会到磁盘上做IO读取，同样的，修改删除操作的数据，如果在buffer poll缓存里面有，则直接修改删除缓存的数据，那么此时缓存和磁盘的数据就出现了不一致，就会出现脏页。

那么此时我们就要问了，有脏页的出现，而且修改删除的操作也在缓存数据中执行，一旦MySQL服务器宕机了，不就会出现数据的丢失吗？不着急，我们慢慢接着看。



出现了脏数据，那么为了避免上面出现的问题，我们就要将脏页更新到磁盘上，这个过程就叫做**刷脏**。但它不是实时去执行刷脏操作的，是异步执行的为了提高效率，为了避免上面说的宕机丢失数据的问题，MySQL为我们做了什么，**redolog日志**就粉墨登场了。



**什么是redolog日志？**

比如我们现在执行了一条sql语句，insert into tablename (XXX, YYY) values (AAA, BBB);

这条语句的结果会写入到buffer pool中，同时也记录了一个redolog日志，表示你做了上面的insert操作。当然了redolog也有自己的buffer缓存区（这个时候就充分体现出来计算机系统中为了提升效率，无处不在的缓存），MySQL的innodb默认是实时刷盘将redolog写到磁盘中的（这一步再多少一下，OS操作系统也有一层缓存，即我们上面那条insert语句先到buffer pool --> OS cache --> 磁盘，依然那句话，无处不缓存，到了OS cache需要有个flush强刷才能写入磁盘中）。这里我们就理解为redolog默认是实时写到磁盘中的。

看了上面的一通强行解释，就会明白redolog用于宕机后的重建数据，假设宕机后，重启数据库服务器后，通过redolog文件将数据恢复。

**这里还有个问题，既然有空去写redolog日志到磁盘上，为什么不直接写到数据库中呢？**

答案很简单，计算机系统中无处不缓存归根结底就是为了提高效率，写redolog文件到磁盘上依然是为了提升效率。

写数据到数据库中会涉及到索引排序的，是随机IO操作写入到磁盘上的，redolog写文件到磁盘上则是顺序写入的。计算机随机IO写入操作一般是100K/S左右，而顺序IO写入操作猜猜是多少？最高可以达到600M/S左右的速度，是不是惊人的差距，这两效率差的可不是一点点哦。

**有了上面的的redolog日志写入还没完，还不能够完全保证数据持久性，一脸懵？**

为什么？这个就要从innodb和磁盘交互的最小单元说起，我们都知道innodb每次从磁盘上读取一页数据默认是16KB，然而操作系统同样也是一页一页的操作数据的，而操作系统默认一页数据是4KB。这样一来，将脏页数据刷到磁盘中需要4次操作，假设我们刷到一半的时候，服务器宕机了，那么我们还是会丢失一页的数据（为啥不是半页数据？因为磁盘上的内容被更新到一半的时候，数据结构有可能混乱，那么就是常见我们常见的文件已损坏）。那么该怎么办呢？我们接着看。



**这时就要double write登场了。**

double就是双倍的意思，也就是说我们会对没一页数据写一个副本，这个副本也会持久化到磁盘上，假设我们服务器崩溃了，我们也可以先通过副本先将这一页数据重建到最初的样子，然后再根据redolog日志依次把数据重建到磁盘上。这样一来，我们就能够保证数据的持久性的特性了。那么什么时候会写副本到磁盘上呢？我们猜想是每次读取这一页数据到buffer poll的时候会将这一页数据做一个备份，double write写入到磁盘上。



#### 怎么实现一致性和原子性呢？

我们这里主要讲一下回滚时的操作，其实主要是通过undolog的操作来完成的。下面我们细细品味一下undolog。

当我们开启事务准备做一系列操作之前，会将事务中的修改数据的镜像（即源数据）写入到undolog日志文件中，至于为什么要写到日志文件中，当然还是效率问题。那么修改的数据只会在buffer pool中体现出来，我们在当前事务中可以查到，未必是真正写入到磁盘中的哟，这个在上面也提到过的。如果一起正常提交事务那么就会引用redolog的操作，将修改数据的操作记录写入到磁盘上。那如果这个事务在提交前，我们需要对数据做rollback，这个时候就需要undolog出场了，源数据就可以从undolog日志中获取。同时也可以保证数据库崩溃时，一些未提交事务的数据需要回滚到最初状态。







