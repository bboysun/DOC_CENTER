## 事务的隔离级别

有四种隔离级别：

1. read-uncommitted：读未提交
2. read-committed：读提交
3. repeatable-read：可重复读
4. serializable：串行化



1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。

3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

**小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表**



MySQL默认的是repeatable-read可重复读隔离级别；Oracle默认的是read-committed读提交隔离级别；

下面的内容，具体可以通过本地MySQL做实验验证；

read-uncommitted：事务A可以读取事务B任何一个未提交的数据修改内容。

read-committed：事务A只能读取事务B提交的数据内容。

repeatable-read：事务A在连续两次查询操作的间隙，事务B做了更新操作并提交，事务A这前后两次查询结果是一样的，避免了不可重复读。只有当事务A做了更新，删除，插入操作后，事务A才能获取事务B更新的值；

这里面主要是通过MVCC版本控制来处理的，MVCC版本控制是MySQL中select不会对版本号做更新，是快照读 ，而insert，update，delete是会更新版本号；

serializable：事务隔离级别为串行化时，读写数据都会锁住整张表；



说到MVCC，那么我们简单聊聊他。

首先说下它要解决什么问题而诞生的，MVCC就是为了解决并发事务效率的问题，再不加锁的情况下完成并发事务。简单理解我们期望并发的事务是互斥的，是需要加锁来控制同步依次完成事务的执行。但这样的效率会比较低，那怎么办呢？就有了MVCC，主要的核心思想就是通过多个版本的数据来避免加锁，从而完成多个事务之间的互斥性，每个事务通过生成自己的快照数据，这些快照数据在数据库中有不同的版本进行隔离，在repeatable read隔离级别中就有充分的体现。整体就是通过空间来换取时间的策略。

那么低层具体是如何实现的呢？简单理解就是在表里的每一行数据都给加了几个隐藏字段，创建版本，删除失效版本，根据不同的版本获取不同的快照数据。

