## 索引的面纱

先说下，我对索引的认知，就MYSQL的索引为例，MySQL一般我们用的都是innodb的引擎，这个引擎的好处就是**索引即数据，数据即索引**。

怎么理解呢？简单理解就是MySQL的innodb的引擎使下存储的数据默认是B+树存储的，以一个自增的主键Id作为B+树的节点划分。用空间来换取时间的方式提高查询效率。

有了上面的大致了解，我们再继续看下。

MySQL每次查询数据的时候，都是以**页**为单位的，一个页一般是16KB，用页的好处会减少MySQL的对磁盘IO的读写次数。MySQL的数据正是由页基本单位组合而成的。

![1583211095396](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1583211095396.png)

每个页中有很多数据可以用链表形式存储，这样一来我们想要查找某条数据时，先找到页，然后在页中的数据进行遍历链表顺序查找即可。但这样效率会太慢。

此时就引入了**页目录**，通过二分法对一个页中的数据分成若干个组，将每一组的最后一条数据作为该页内的一个偏移量抽出来做一个**槽**（slot），按顺序存储到当前页面靠后的位置，作为一个页目录。

![1583211577077](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1583211577077.png)

这样就提高了页内数据的查询，二分查找的时间复杂度为log(n)，这里我们给出一个log(n)的一个量化的概念，就是在100亿个有序数组中想要找到我们的target目标值，通过二分法只需要33次就能查到。log2(1百亿) ~33.219，说到这里是不是很惊人。

OK，这样每个页就搞定了，那问题又来了，页慢慢的变多了怎么办。

其实每个页也有指向前一个，后一个的指针，多个页也就能组成一个链表结构，这样每次遍历页的链表就好了，不足的地方同样也是效率太低。那怎么办呢？

沿用页内数据的思想，当页数太多时，就用2-3树生成的方法向上融合生成一个非叶子结点（内部节点），这个内部节点不会存储真正的数据，只会存储索引，最终生成目录页，完成B+树的构建。

![1583212257688](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1583212257688.png)

总结一下B+树：

1. 叶子节点存放真正数据，非叶子节点存储索引数据。

2. B+树的所有数据都在叶子结点，一般查询效率稳定，一般查询3次即可。一般三层数据结构能够存储两千万条数据。

   

   

   