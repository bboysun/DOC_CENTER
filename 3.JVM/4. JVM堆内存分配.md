## JVM堆内存分配

首先了解一下堆内存的大致分配。

堆内存为了方便垃圾回收，将堆内存主要分为新生代和老年代，可以参考上一篇的jvm的参数配置文章。==新生代官方给出的是堆内存的3/8大小。==

**新生代**

新生代又划分了 `Eden`，`from Survivor` 和`to Survivor`三个区，==这三个区的官方推荐的默认比例是8:1:1==，当然也可以自定义通过参数`-XX:SurvivorRatio=8`进行配置。



新生成的对象一般优先在新生代中的`Eden`区生成，当对象越来越多时，**`Eden`区的内存不足，则会发生`minorGC**`，由于`java`对象都有朝生夕灭的特性，所以`minorGC`通常比较频繁，效率也很高。



在`minorGC`过程中，JVM会根据==复制算法==将存活的对象拷贝到另一个未使用的`Survivor`区域，如果`Survivor`区域内存也不足时，则会使用==分配担保策略==将对象移动到老年代中。



**老年代**

当一个大对象大到Eden区无法装下的时候，则是直接分配到老年代的。



说到minorGC，就不得不说fullGC，fullGC是指发生在老年代，这里指发生在老年代的GC，不论是效率还是速度都比minorGC慢的多，回收时还会发生 stop the world，是程序发生停顿，应该尽量避免fullGC 的发生。



#### 调试JVM运行时堆内存

1. 应用程序通过byte[]数组对象的新建来不断增加JVM的堆内存。
2. java -Xms1024m -Xmx1024m -Xss256k -Xmn384m -jar XXX/XXX.jar &   通过java命令启动应用程序
3. jstat -gcutil 进程号 毫秒数 次数，如jstat -gcutil XXX 1000 3，表示的含义就是1秒钟输出一次该进程的gc，堆内存的情况，总共输出3次

![1582800450005](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582800450005.png)

