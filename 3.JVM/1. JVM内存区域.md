## JVM运行时数据区域

#### 一、JVM区域的划分

JVM主要的区域是：堆，java虚拟机栈，程序计数器，方法区，本地方法栈；接下来，我们一个一个简单了解和认识。

**程序计数器**：用来记录每个线程当前执行的字节码指令的位置。所以每个线程都有自己的程序计数器。

![1582718526753](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582718526753.png)

**java虚拟机栈**：用来保存每个方法内的局部变量等数据。因为每个线程都会去执行各种方法，所以每个线程都会有自己的栈。如果一个线程执行了一个方法，就会回这个方法调用创建一个对应的==栈帧==。栈帧里面又有局部变量表，操作数栈，动态链接，方法出口等东西。==调用任何方法时，都会给方法创建栈帧，然后再入栈==。

**多说一句：这里面也会引出多线程问题，当线程太多会造成的是栈内存溢出，因为一个线程会默认分配1M的栈内存，当多线程场景下，栈太多就会造成栈内存溢出。所以说要用线程池的优势**

![1582718545745](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582718545745.png)

![1582718556975](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582718556975.png)

**堆**：用来存放我们在代码中创建的各种对象。

```java
public void sayHello(String book) {
    Student student = new Student();
    student.study(book);
}
```

上面代码中的`new Student()`就是创建了一个`Student`对象实例，类似这样的对象实例会存在java堆内存中。

然后方法的栈帧的局部变量表里，这个引用类型的`student`局部变量会存储`Student`对象的地址。你可以认为局部变量表里的`student`指向了java堆内存的`Student`对象实例。

![1582719051436](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582719051436.png)

**方法区（Metaspace）**：JDK 1.8之前的版本叫方法区，主要存放类似Student类自己的信息，平时用到的各种类的信息，都会存放在这个区域里，还会有一些常量池的东西存在这个区域，JDK 1.8以后，这块区域的名字改了叫Metaspace，元数据空间，当然还是存放各种类的相关信息。

**本地方法栈**：在JDK底层API里，比如==NIO==，IO，网络Socket相关的，源码中会发现很多地方都不是java代码，而是会走native方法，去调用本地操作系统里面的一些方法，可能调用的是C语言的方法，或者底层类库中的方法。

`public native int hashCode();`

如果有线程调用了这种native方法时，线程就会有自己对应的本地方法栈，这个里面也是跟Java虚拟机栈类似，也是存放了各种native方法的局部变量等类似的信息。



#### 总结如下图：

![1582802189051](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582802189051.png)



