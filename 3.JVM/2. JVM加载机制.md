## JVM加载机制

#### 一、前言

JVM是怎么运行的，先会将我们源码（.java文件）编译为字节码文件（.class文件），然后类加载器会把字节码文件中的类加载到JVM中，接着是JVM来执行我们写好的那些类中的代码，整体是这样的一个过程。

![1566111910927](image\1566111910927.png)

#### 二、JVM加载过程

==需要明白的一点：一个类什么时候才会去装载到JVM中的呢，是在被主动调用的时候才会去加载。==

**加载过程** ：验证:arrow_right:准备:arrow_right:解析:arrow_right:初始化:arrow_right:使用:arrow_right:卸载

1. 验证：简单来说，这一步就是根据Java虚拟机规范，来校验你加载进来的“.class”文件中的内容，==是否符合指定的规范==。你的“.class”文件被人篡改了，里面的字节码压根儿不符合规范，那么JVM是没法去执行这个字节码的！

2. 准备：这个阶段其实也很好理解，咱们都知道，我们写好的那些类，其实都有一些类变量，比如下面的这个“ReplicaManager”类：

![1566112313909](image\1566112313909.png)

接着，就会进行准备工作，这个准备工作，其实就是给这个“ReplicaManager”类分配一定的内存空间。然后给他里面的==类变量（也就是static修饰的变量）分配内存空间，来一个默认的初始值==。比如上面的示例里，就会给“flushInterval”这个类变量分配内容空间，给一个“0”这个初始值。

3. 解析：这个阶段干的事儿，实际上是把**符号引用替换为直接引用**的过程，其实这个部分的内容很复杂，涉及到JVM的底层

4. 核心阶段初识化：之前说过，==在准备阶段时，就会把我们的“ReplicaManager”类给分配好内存空间，另外他的一个类变量“flushInterval”也会给一个默认的初始值“0”==，那么接下来，在初始化阶段，就会正式执行我们的类初始化的代码了。

   那么什么是类初始化的代码呢？我们来看看下面这段代码：

   ![img](https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLYRaEsdO21Vmky5Y4L9jaMiaVjjiczd76USnL7saJdibbicUdhiakScqHXKhQkju2L3sHjqVLbcHEUrkJQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   大家可以看到，对于“flushInterval”这个类变量，我们是打算通过Configuration.getInt("replica.flush.interval")这段代码来获取一个值，并且赋值给他的

   但是在准备阶段会执行这个赋值逻辑吗？

   **NO！**==在准备阶段，仅仅是给“flushInterval”类变量开辟一个内存空间，然后给个初始值“0”罢了。==

   ==自己代码本身的这段赋值的逻辑什么时候执行呢？答案是在**“初始化”**阶段来执行。==

   在这个阶段，就会执行类的初始化代码，比如上面的  Configuration.getInt("replica.flush.interval")  代码就会在这里执行，完成一个配置项的读取，然后赋值给这个类变量“flushInterval”。

   ==另外比如下图的static静态代码块，也会在这个阶段来执行。==

   类似下面的代码语义，可以理解为类初始化的时候，调用“loadReplicaFromDish()”方法从磁盘中加载数据副本，并且放在静态变量“replicas”中：

   ![img](https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLYRaEsdO21Vmky5Y4L9jaMiafVc3lxRHGebzKqqIL5EJ0UdyJvocIBj03phThnx1OTEibQdGthEzzVg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   那么搞明白了类的初始化是什么，就得来看看类的初始化的规则了。

   这里还有一个**非常重要的规则**，==就是如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类==。

   #### 三、加载器

   那么**Java里有哪些类加载器呢？**简单来说有下面几种：

   **（1）启动类加载器**

   **Bootstrap ClassLoader**，他主要是负责加载我们在机器上安装的Java目录下的核心类的

   相信大家都知道，如果你要在一个机器上运行自己写好的Java系统，无论是windows笔记本，还是linux服务器，是不是都得装一下JDK？

   那么在你的Java安装目录下，就有一个“**lib**”目录，大家可以自己去找找看，这里就有Java最核心的一些类库，支撑你的Java系统的运行。

   所以一旦你的JVM启动，那么首先就会依托启动类加载器，去加载你的Java安装目录下的“lib”目录中的核心类库。

   **（2）扩展类加载器**

   **Extension ClassLoader**，这个类加载器其实也是类似的，就是你的Java安装目录下，有一个“lib\ext”目录

   这里面有一些类，就是需要使用这个类加载器来加载的，支撑你的系统的运行。

   那么你的JVM一旦启动，是不是也得从Java安装目录下，加载这个“lib\ext”目录中的类？

   **（3）应用程序类加载器**

   **Application ClassLoader**，这类加载器就负责去加载“ClassPath”环境变量所指定的路径中的类

   其实你大致就理解为去加载你写好的Java代码吧，这个类加载器就负责加载你写好的那些类到内存里。

   **（4）自定义类加载器**

   除了上面那几种之外，还可以自定义类加载器，去根据你自己的需求加载你的类。

   #### 四、双亲委派机制

   ![1566112804940](image\1566112804940.png)

JVM的类加载器是有亲子层级结构的，就是说启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。

就是假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载

但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器。

听完了上面一大堆绕口令，是不是很迷茫？别着急，咱们用一个例子来说明一下。

比如你的JVM现在需要加载“ReplicaManager”类，此时应用程序类加载器会问问自己的爸爸，也就是扩展类加载器，你能加载到这个类吗？

然后扩展类加载器直接问自己的爸爸，启动类加载器，你能加载到这个类吗？

启动类加载器心想，我在Java安装目录下，没找到这个类啊，**自己找去**！

然后，就下推加载权利给扩展类加载器这个儿子，结果扩展类加载器找了半天，也没找到自己负责的目录中有这个类。

这时他很生气，说：明明就是你应用程序加载器自己负责的，你自己找去。

然后应用程序类加载器在自己负责的范围内，比如就是你写好的那个系统打包成的jar包吧，一下子发现，就在这里！然后就自己把这个类加载到内存里去了。

这就是所谓的**双亲委派模型：**先找父亲去加载，不行的话再由儿子来加载。

这样的话，可以避免多层级的加载器结构重复加载某些类。