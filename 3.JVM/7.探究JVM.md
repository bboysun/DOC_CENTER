# 探究JVM

[toc]

## 一、JVM内存结构

Java虚拟机简称JVM，其内存空间分为5个部分：

- 程序计数器
- Java虚拟机栈
- 本地方法栈
- 堆
- 方法区（Java官方HotSpot虚拟机中，jdk8版本是用元数据区实现的，jdk7版本是用永久代实现方法区）

对比JDK8和JDK7，最大的区别是：元数据区取代了永久代。元数据区本质上和永久代是类似的，都是对JVM规范中方法区的实现。不过元数据区与永久代最大的区别是：元数据区不在虚拟机中，而是在本地内存中；

<img src="/Users/darrylsun/Library/Application Support/typora-user-images/image-20220307161550110.png" alt="image-20220307161550110" style="zoom:50%;" />

### A. 程序计数器（PC寄存器）

程序计数器是一块较小的内存空间，是当前线程正在执行的一条字节码指令的地址。如果当前线程正在执行的是一个本地方法，那么此时程序计数器为undefined。

程序计数器的 **<u>作用</u>**：

- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。
- 在多线程场景中，程序计数器记录的是当前线程执行的位置，从而当线程切换时，每个线程可以清楚知道上次执行的位置。

程序计数器的 **<u>特点</u>**：

- 是一块较小的内存空间
- 线程私有
- 生命周期随着线程的创建而创建，随着线程的结束而销毁
- 唯一一个不会出现`OutOfMemoryError`的内存区域

### B. Java虚拟机栈（Java栈）

Java虚拟机栈是描述Java方法运行过程的内存模型。Java虚拟机栈会为每个即将运行的Java方法创建一块名为“栈帧”的区域，用于存放该方法运行过程中的一些必要信息，如：

- 局部变量表
- 操作数栈
- 动态链接
- 方法出口信息
- ......

<img src="/Users/darrylsun/Library/Application Support/typora-user-images/image-20220307162920045.png" alt="image-20220307162920045" style="zoom:50%;" />

**<u>压栈出栈</u>**：

当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。（所以方法中的局部变量需要初始化）

Java虚拟机栈栈顶的栈帧是当前正在执行的活动栈帧，也就是当前正在执行的方法。程序计数器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。

由于java虚拟机栈是与线程对应的，数据不是线程共享的（即线程私有的），因此不用关心数据一致性问题，也不会存在同步锁的问题。

**<u>局部变量表</u>**：

定义为一个数字数组，主要用于存储方法参数、定义在方法体内部的局部变量，数据类型包括各类基本数据类型，对象引用，以及`return address`类型。局部变量表容量大小是在编译期确定下来的。最基本的存储单元是`slot`，32位类型占用一个`slot`，64位类型（如：long，double等）占用两个`slot`。

`slot`的理解：

- JVM虚拟机会为局部变量表中的每个`slot`都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。
- 如果当前栈帧是由构造方法或者实例方法创建的，那么该对象引用this，会存在index为0的slot处，其余的参数表顺序继续排列。
- 栈帧中的局部变量表中的槽位是可以重复使用的，如果一个局部变量过了其作用域，那么其作用域之后申请的新的局部变量就有可能会复用过期的局部变量的槽位，从而达到节省资源的目的。

在栈帧中，与性能调优关系最密切的部门，就是局部变量表。方法执行时，虚拟机使用局部变量表完成方法的传递；局部变量表也是重要的垃圾回收的根结点，只要被局部变量表中直接或者间接引用的对象都不会被回收。

**<u>操作数栈</u>**：

操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

如果操作数时存储在内存中，频繁进行内存读写操作势必会影响执行速度；所以将栈顶元素全部缓存到物理CPU的寄存器中，以此降低对内存的读写次数，提升执行效率。

每一个操作数栈会拥有一个明确的栈深度，用于存储数值，最大深度在编译期就定义好的。32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度的操作数。

并非采用访问索引方式进行数据访问，而是只能通过标准的先进后出的入栈，出栈操作完成一次数据访问。

**<u>方法调用</u>**：

- 静态链接：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行时期保持不变，这种情况，将调用方的符号引用转为直接引用的过程称为静态链接；

- 动态链接：如果被调用的方法无法在编译期被确定，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接；

- 方法绑定：早期绑定：被调用的目标方法如果在编译期可知，且运行期保持不变；晚期绑定：被调用的目标方法如果在编译期不可知，只能在运行期根据实际的类型绑定相关方法。

- 非虚方法：如果方法在编译期就确定了具体的调用版本，则这个版本在运行时时不可变的。这样的方法称为非虚方法；静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法，除了这些以外都是虚方法。

- 虚方法：面向对象编程中，会很频繁的使用动态分配，如果每次动态分配的过程都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率，因此为了提高性能，JVM采用在类的方法区建立一个虚方法表，使用索引表来代替查找；每个类都有一个虚方法表，表中存放着各个方法的实际入口。虚方法表会在类加载的链接阶段被创建，并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法也初始化完成。

- 方法重写的本质：

  1. 找到操作数栈顶的第一个元素所执行的对象的实际类型，记做C。如果类型C中找到与常量池中描述符和简单名称都相符的方法，则进行第2步访问权限校验，如果没有找到跳到第3步。

  2. 如果通过，则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.illegalAccessError异常；

  3. 否则按照继承关系从下往上依次对C的各个父类进行第1步的搜索和验证的过程；

  4. 如果最终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

**<u>Java虚拟机栈特点</u>**：

- 运行速度快，仅次于PC寄存器。
- 局部变量表随着栈帧的创建而创建，它的大小在编译期时确定，创建时只需分配事先规定的大小。在方法运行过程中，局部变量表的大小不会发生改变。
- 会出现两种异常：StackOverFlowError若Java虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，抛出该异常。OutOfMemoryError如允许动态扩展，当线程请求栈时内存用完了，无法再动态扩展时，抛出该异常。
- Java虚拟机栈时线程私有的，随着线程创建而创建，随着线程结束而销毁。
- 出现StackOverFlowError时，内存空间可能还有很多。

### C. 本地方法栈（C栈）

本地方法栈时为JVM运行native方法准备的空间，由于很多native方法都是用C语言实现的，所以通常又称为C栈。它与Java虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。

栈帧变化过程，本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表，操作数栈，动态链接，方法出口信息等。

方法执行完成后，相应的栈帧也会出栈，并释放内存空间，也会抛出StackOverFlowError和OutOfMemoryError异常。

### D. 堆

堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。

**<u>堆特点</u>**：

- 线程共享，整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。
- 在虚拟机启动时创建。
- 是垃圾回收的主要场所。
- 堆可分为新生代（Eden区：from survivor, to survivor）和老年代。
- Java虚拟机规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。

不同的区域存放不同生命周期的对象，但对于主流的虚拟机，堆的大小时可以扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出`OutOfMemoryError`异常。

新生代与老年代有一些基本的配置常识，老年代相比新生代生命周期会更长。新生代和老年代空间默认比例为1:2，JVM调参数，XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3。HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1。几乎所有的Java对象都是在Eden区被new出来的，Eden区放不了的大对象，就直接进入老年代。

对象在堆中是如何分配的呢？分配过程如下：

- new的对象先放在Eden区，大小有限制。
- 如果创建新对象时，Eden空间填满了，就会触发Minor GC，将Eden区中不再被其他对象引用的对象进行销毁，再加载新的对象放到Eden区；特别注意的是Survivor区满了是不会出发Minor GC的，而是Eden空间填满了，Minor GC才顺便清理Survivor区。
- 将Eden区中剩余的对象移到Survivor 0区。
- 再次触发垃圾回收，此时上次放在Survivor 0区的对象，如果没有回收，就会放到Survivor 1区。
- 再次经历垃圾回收，又会出现幸存者重新放回Survivor 0 区，一次类推。
- 默认15次循环，超过15次，则会将Survivor区幸存下来的转去老年区，JVM参数配置：`-XX: MaxTenuringThreshold=N`进行设置

**<u>Full GC / Major GC触发条件</u>**

显示调用System.gc()，老年代的空间不够，方法区的空间不够等都会触发Full GC，同时对新生代和老年代进行回收，Full GC的STW的时间最长，应该要避免的；

**<u>逃逸分析</u>**

随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配，变量替换优化技术将会导致一些变化，所有的对象都分配到堆上也渐渐变得不那么绝对了。

这是一种可以有效减少Java内存堆分配压力的分析算法，通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围

