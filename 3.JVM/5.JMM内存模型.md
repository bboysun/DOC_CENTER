## JMM内存模型

Java内存模型时共享内存的并发模型，线程间主要通过读写共享变量来完成隐式通信，JMM控制Java线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见。

![1582803150412](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582803150412.png)

内存可见性又是怎样理解的。

从 JDK5 开始，java 内存模型提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。

如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。

**这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。**

如果 A happens-before B，那么 Java 内存模型将向程序员保证—— A 操作的结果将对 B 可见，且 A 的执行顺序排在 B 之前。

重要的 happens-before 规则如下：

1. 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
2. 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。
3. volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。
4. 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。

#### volatile关键字

volatile 可以说是 JVM 提供的最轻量级的同步机制，当一个变量定义为volatile之后，它将具备两种特性：

1. **保证此变量对所有线程的可见性。**而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。

注意，volatile 虽然保证了可见性，但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。而 synchronized 关键字则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得线程安全的。

1. **禁止指令重排序优化。**普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。