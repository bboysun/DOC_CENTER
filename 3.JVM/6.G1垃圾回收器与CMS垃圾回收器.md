## G1垃圾回收器与CMS垃圾回收器

简单介绍一下G1垃圾回收器，是一个分代的增量的并行与并发的标记复制垃圾回收器。它的设计目标是为了适应现在不断扩大的内存和不断增长的CPU数量，进一步降低了暂停时间，同时兼顾良好的吞吐量。

CMS，是并发标记清除算法的垃圾回收器。GC过程短暂停，适合对延时要求高的的服务，用户线程不允许长时间停顿。

G1和CMS的简单对比：

1. G1回收后的空间是连续的，CMS回收后的空间是不连续的。应用服务长时间运行CMS容易造成内存碎片。
2. G1回收器将内存划分成一个一个固定大小的Region的，内存回收是以Region为单位进行回收的。
3. G1还有个特性是软实时性，即我们用户可以指定G1在规定时间内完成垃圾回收，G1会在这个时间内尽力完成垃圾回收。



**接下来，我们再看下他们各自的算法流程大概是怎样的？**

**CMS垃圾回收器的流程：**

CMS有两种触发机制，一种是周期性的Old GC，一种是主动触发Old GC。周期性的Old GC就是在JVM中有一个ConcurrentMarkSweepThread两秒钟判断一次是否需要触发Old GC。当然是需要一个触发条件的。他的触发条件如下：

1. 老年代使用率达到了阈值默认是92%。
2. 新生代晋升担保失败，老年代是否有足够的空间来容纳全部的新生代对象或者历史平均晋升老年代的对象数量，如果不够的话就会提早进行老年代的垃圾回收。

大概的流程可以理解为标记出存活对象，然后将垃圾对象进行回收，但实际的运行阶段就不止这么简单了。

![](image\cms_flow.PNG)

1. initialMarking：初识化标记，整个过程STW，标记GC root可达的老年代对象。遍历新生代对象，标记可达的老年代对象。
2. marking：并发标记，该阶段标记出InitiaMarking阶段标记出来的的存活对象，然后继续递归标记这些对象的可达的对象。该阶段GC线程和应用服务线程是并发的。（因为是并发，所以会有一些漏标记的对象）
3. precleaning：处理上一个marking并发阶段中漏标记的对象，比如新生代分配了一个对象A，这个对象A引用了老年代的对象B，那么这个时候，会将老年代的对象B重新标记。
4. finalMarking：重新标记阶段（STW过程），遍历新生代重新标记，根据GC root重新标记，遍历老年代重新标记，这里面老年代的dirty card大部分都在clean阶段处理过了。
5. sweep：并发清理阶段，清理掉不存活的对象。
6. resizing：调整堆大小。

**注**：常见的GC root，比如，system class loader，boot class loader，处于激活状态的线程，栈中的对象，正在被使用同步的各种锁对象等。



**G1垃圾回收器算法整体可以分为两个部分**：

1. Marking cycle phase：标记阶段，该阶段不断的循环。
2. Evacuation phase：该阶段负责把一部分的region的活对象拷贝到空的region里面去，然后回收原来的region空间。

同时，G1算法有两种模式，一种是我们常见的young gc，该模式只会回收young region内存区域，算法是通过调整young region的数量来达到软实时的目的。另外一种模式，就是mixed gc，该模式会回收young region和old region两个区域的内存

G1垃圾回收器不会在对象头中添加字段来标记是否需要回收，而是采用bitmap方式来记录一个对象被标记的情况，G1如果需要使用这些标记信息的时候，只需要扫描bitmap就可以了。

Marking cycle phase：大致又可以分类和CMS类似的几个阶段进行处理。

1. Initial marking phase：G1收集器会扫描所有的根。
2. root region scanning phase：扫描存活的region中指向老年代的被initial marking phase标记的引用及引用对象。
3. concurrent marking phase：并发的标记整个堆中的存活对象。
4. remark phase：该阶段需要处理并发标记阶段产生的新的存活对象的引用。
5. cleanup phase：清理阶段，该阶段会计算出每一个region中存活的对象（这是Stop the world的过程），并把完全没有存活对象的region直接发到空闲列表中，同时会重置remember set。

**注**：remember set解释

在传统的分代垃圾回收算法里面，RS(Remember Set)被用来记录分代之间的指针。在G1回收器里面，RS被用来记录从其他Region指向一个Region的指针情况。G1垃圾回收器进一步把RS划分成了多个哈希表。每一个线程都在各自的哈希表里面修改。最终，从逻辑上来说，RS就是这些哈希表的集合。哈希表是实现RS的一种通常的方式之一。它有一个极大的好处就是能够去除重复。这意味着，RS的大小将和修改的指针数量相当。而在不去重的情况下，RS的数量和写操作的数量相当。



Evacuation phase：该阶段又可以大致分为两个阶段：

1. 从region中选出若干的region进行回收。
2. 把这些region中存活的对象复制到空闲的region中，同时把已经回收的region放到空闲的region列表中。