## HashMap集合

#### 一、HashMap

简单理解，HashMap的数据结构有三种组成，数组 + 链表 + 红黑树

对应源码来看，Node<K, V>是需要存储的K-V数据，同时有一个table==数组==，数组中的元素就是Node<K, V>；Node<K, V>对象中又有next指针，就很容易构成一个==链表==，另外，还会有一个TreeNode<K, V>的内部类，这就是==红黑树==的组成元素。

大概的数据结构了解完成以后，接着看下HashMap的关键变量，初始化容量（默认1<<4 = 16） + 负载因子（默认0.75） + threshold扩容阈值 （=初始化容量*负载因子） + 变成红黑树的阈值（默认是8个元素） + 返回链表的阈值（默认是6个元素） + 最大容量 （1<<30 = 1073741824） + size大小 等。

![1582807427861](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582807427861.png)

需要注意的是，threshold = initial capacity * loadFactor，超过这个阈值HashMap就要resize扩容。在HashMap构造函数中threshold并不是初始化为我们刚刚理解的值，而是默认的给的是默认值，只有当put方法操作时，在put方法中有个resize的方法，在resize方法中会初始化table数组，同时重新计算threshold值，会按起初理解的计算方式进行重置。

![1582867214819](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582867214819.png)

![1582867229385](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582867229385.png)



tableSizeFor（）方法只是为了计算给定值的最接近的2的次方值。

![1582807692330](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582807692330.png)

了解完关键变量后，我们看下如何进行数据的存储。

简单理解我们要存储一个Node<K,V>的键值对到map集合中，我们会先对K进行hash运算得到一个hash值hash(K)，以hash(K)为角标在table[]数组中找到对应的位置，如果该位置没有数据则将Node<K,V>存储进去，如果该位置有数据Node1<K1,V1>则先判断K1和K是否相等，如果相等，则用我们即将put的Node<K,V>将原来的值覆盖，如果不相等，我们就需要在该位置下依次到该位置下的链表进行比较如果都没有就在链表的尾部进行插入，当链表的长度超过默认的8时，链表会变成红黑树，则会在红黑数上进行遍历比较，如果都不相同，则在红黑树的尾部插入。

以上就是一个hashMap插入存储数据的过程。

整理的结构如下图：

![1582808858893](C:\Users\Darryl\AppData\Roaming\Typora\typora-user-images\1582808858893.png)

链表的查询时间复杂度O(n)，红黑树的查询时间复杂度O(logn)，当n很多时，链表转换为红黑树，是的查询效率更高。



最后简单说下hashMap和hashTable的区别：

1. hashMap 存储的Key，Value均可为null，hashTable不行。
2. hashMap线程不安全，hashTable线程安全，因为hashTable的put，remove，等方法都是synchronized方法。
3. hashMap由于没有使用对象锁，所以效率会更高。



#### 注：

1. 问：为什么数组的容量都是2的次方？

   答：为了提高计算效率，2的次方的数据容量，可以通过位运算，容量-1 & hash(key) 得到的值等价于 hash(key)对容量取模运算。主要是在更快计算出put数据在数组的位置。

2. 问：hashMap扩容后，对现有的数据进行怎样的分配？

   答：因为扩容都是翻倍的，二进制刚好多了一位，简单说，容量从8扩容到16，原来的数据在位置4，扩容后，要么在4位置上，要么在4+8=12的位置上。可以通过位运算得到。扩容条件是：map集合的size大于扩容的阈值后，再进行扩容，主要是为了解决冲突的。==此时我们对比一下redis中的hash扩容，redis中的hash扩容有两个条件，1.size大于容量且可以扩容就直接扩容，相当于负载因子为1，2.size是容量的5倍时，就进行扩容，相当于负载因子是5，redis这么做是因为，redis的瓶颈在于内存，宁愿牺牲一些效率也要保证内存的充分利用==



最后，下面的博客写的很棒，可以参考。

https://www.jianshu.com/p/ee0de4c99f87





