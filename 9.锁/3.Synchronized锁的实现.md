## Synchronized锁的实现

我们都用过synchronized关键字，在多线程中用于保证线程安全，保证线程间的可见性和原子性。

synchronized我们一直说他是个对象锁，那么到底这个锁在哪里体现的，为什么在jdk1.6以后，官方推荐还是要用synchronized关键字而不是用可重入锁，这些问题我们在下面一个一个的完美解释。

**Synchronized锁的3种使用形式（使用场景）：**

Synchronized修饰普通同步方法：锁对象当前实例对象；
Synchronized修饰静态同步方法：锁对象是当前的类Class对象；
Synchronized修饰同步代码块：锁对象是Synchronized后面括号里配置的对象，这个对象可以是某个对象（xlock），也可以是某个类（Xlock.class）；

使用的过程中要注意的是：

1. 使用synchronized修饰非静态方法或者使用synchronized修饰代码块时制定的为实例对象时，同一个类的不同对象拥有自己的锁，因此不会相互阻塞。
2. 使用synchronized修饰类和对象时，由于类对象和实例对象分别拥有自己的监视器锁，因此不会相互阻塞。
3. 使用使用synchronized修饰实例对象时，如果一个线程正在访问实例对象的一个synchronized方法时，其它线程不仅不能访问该synchronized方法，该对象的其它synchronized方法也不能访问，因为一个对象只有一个监视器锁对象，但是其它线程可以访问该对象的非synchronized方法。
4. 线程A访问实例对象的非static synchronized方法时，线程B也可以同时访问实例对象的static synchronized方法，因为前者获取的是实例对象的监视器锁，而后者获取的是类对象的监视器锁，两者不存在互斥关系。
   



**为什么jdk高版本官方推荐使用synchronized关键字**

synchronized在jdk中做了一路的优化，其实一直会疑惑，这个锁到底存在哪里呢？答案是存在锁对象的对象头的MarkWord中。那么MarkWord在对象头中到底长什么样，也就是它到底存储了什么呢？

![](E:\小宝藏\DOC_CENTER\9.锁\image\sync.png)

在Hotspot中，对象的监视器（monitor）锁对象由ObjectMonitor对象实现（C++），其跟同步相关的数据结构如下：

```c++

ObjectMonitor() {
    _count        = 0; //用来记录该对象被线程获取锁的次数
    _waiters      = 0;
    _recursions   = 0; //锁的重入次数
    _owner        = NULL; //指向持有ObjectMonitor对象的线程 
    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
}
```

对于一个synchronized修饰的方法(代码块)来说：

1. 当多个线程同时访问该方法，那么这些线程会先被放进_EntryList队列，此时线程处于blocking状态_
2. 当一个线程获取到了实例对象的监视器（monitor）锁，那么就可以进入running状态，执行方法，此时，ObjectMonitor对象的_owner指向当前线程，_count加1表示当前对象锁被一个线程获取
3. 当running状态的线程调用wait()方法，那么当前线程释放monitor对象，进入waiting状态，ObjectMonitor对象的_owner变为null，_count减1，同时线程进入_WaitSet队列，直到有线程调用notify()方法唤醒该线程，则该线程重新获取monitor对象进入_Owner区
4. 如果当前线程执行完毕，那么也释放monitor对象，进入waiting状态，ObjectMonitor对象的_owner变为null，_count减1



细心的我们会发现对象头中有个锁状态的字段，这就是jdk一路优化synchronized的证据。其中从低到高，包括：无锁-->偏向锁-->轻量级锁-->重锁。

**偏向锁-->轻量级锁**

经过HotSpot的作者大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。

当线程A访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为偏向锁不会主动释放锁，因此以后线程A再次获取锁的时候，需要比较当前线程的threadID和Java对象头中的threadID是否一致，如果一致（还是线程A获取锁对象），则无需使用CAS来加锁、解锁；

如果不一致（其他线程，如线程B要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程A的threadID），那么需要查看Java对象头中记录的线程A是否存活，

如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程B）可以竞争将其设置为偏向锁；

如果存活，那么立刻查找该线程（线程A）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程A，撤销偏向锁，将锁升级为轻量级锁，如果线程A不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程B。

偏向锁默认是开启的，如果不想启用可以在启动应用服务过程中使用参数`-XX:-UseBiasedLocking = false`进行关闭，同时可以使用`-XX:BiasedLockingStartUpDelay=0`在应用服务启动时，没有延时的开启偏向锁。

**轻量级锁-->重量级锁**

轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。

线程A获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程A的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord），然后使用CAS把对象头中的内容替换为线程A存储的锁记录（DisplacedMarkWord）的地址；

如果在线程A复制对象头的同时（在线程A，CAS之前），线程B也准备获取锁，复制了对象头到线程B的锁记录空间中，但是在线程B，CAS的时候，发现线程A已经把对象头换了，线程B的CAS失败，那么线程B就尝试使用自旋锁来等待线程A释放锁。

但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，如果自旋次数到了线程A还没有释放锁，或者线程A还在执行，线程B还在自旋等待，这时又有一个线程C过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。

值得注意的是锁是一路升级，不能降级的。

**锁粗化**

按理来说，同步块的作用范围应该尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，缩短阻塞时间，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。 
但是加锁解锁也需要消耗资源，如果存在一系列的连续加锁解锁操作，可能会导致不必要的性能损耗。 
锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。
