[TOC]

# 一个单例的蝴蝶效应

## 一、蝴蝶挥了挥翅膀

设计模式想必大家应该都不陌生的吧，在我们日常工作中时常都会碰到或者用到，大体分为三类：创建型模式，结构型模式和行为型模式；今天我们不是讲所有的设计模式的，今天只是想从一个设计模式入手，看看他到底如何扇扇一翅膀如何能在大洋彼岸刮起一场飓风的。

就从我们耳熟能详，也是用的最多错的最多的单例模式入手吧！！！

单例模式是我们常见的一种创建型模式，简单概括下创建型模式，创建型模式说白了就是创建一个又一个的对象，我们最熟悉的就是不停的 `new` 一个对象，但往往我们需要更友好，更易扩展，更有特性的创建方式，于是在各种诉求中就有一个特性的`case`，需要我们在整个应用程序中有且仅有一个对象的实例，这就是我们所说的单例模式。

单例我们经常知道的比如饿汉模式，直接上代码说明，代码中有明确的注释，一定要看注释哟！！！

```java
/**
 * @Author: darrylsun
 * @Description: 单例模式--饿汉模式
 * @Date: 2023/07/22
 */
public class SinglePattern {

    // 私有化构造函数，堵住其他地方创建实例的入口
    private SinglePattern() {
        System.out.println("我被实例化了");
    }

    // 创建私有的静态实例，类加载过程中已经被创建
    // 初始化的顺序无法确定，如果该类依赖于其他类的初始化，那就会有问题！！！
    private static SinglePattern instance = new SinglePattern();

    // 静态方法获取唯一的实例，这样我们就构建好了一个单例
    public static SinglePattern getInstance() {
        return instance;
    }

    // 假设这里有一个静态方法，开发者仅仅只是想调用该方法不想实例化这个对象占用空间，不好意思，这个类已经被实例化了！！！
    public static String findJay() {
        return "find Jay Chou";
    }


    public static void main(String[] args) {
        /**
         * 输出结果：
         * 我被实例化了
         * find Jay Chou
         */
        System.out.println(SinglePattern.findJay());

        // 获取单例实例
        // System.out.println(SinglePattern.getInstance());
    }
}
```

此时，饿汉模式的单例挥动的翅膀，已经为我们引发了下一个问题【类加载】的问题，我们后面再说，先把单例的两种模式都说完哈～～～

接着我们再说说懒汉模式，还是一如既往的直接看代码，还是老规矩，一定要看注释哟！！！

```java
/**
 * @Author: darrylsun
 * @Description: 单例 懒汉模式
 * @Date: 2023/07/22
 */
public class LazySinglePattern {

    // 依然堵住被随意创建对象的入口，私有化构造函数
    private LazySinglePattern() {
        System.out.println("我又被初始化了");
    }

    // 声明我们需要的单例实例化对象，这里需要留意 volatile 关键字哟！！！
    private static volatile LazySinglePattern instance;

    // 双重锁校验，保证多线程环境中单例的线程安全问题！！！
    public static LazySinglePattern getInstance() {
        if (instance == null) {
            synchronized (LazySinglePattern.class) {
                if (instance == null) {
                    instance = new LazySinglePattern();
                }
            }
        }
        return instance;
    }

    public static String fingJay() {
        return "find Jay Chou again";
    }

    public static void main(String[] args) {
        /**
         * 输出结果：
         * find Jay Chou again
         */
        System.out.println(LazySinglePattern.fingJay());

        // 获取单例实例
        // System.out.println(LazySinglePattern.getInstance());
    }
}
```

此时懒汉模式的单例也已经挥动了自己的翅膀，为我们带来了一个很重要的关键字`volatile`和`synchronized`，因为懒汉模式是在我们需要的时候的才会创建对象实例，这样就需要我们自己来保证单例对象在多线程环境下的线程安全问题。至于这两个关键字我们还是放到后面慢慢品尝。

第一章节内容的最后，我还是给出日常开发过程中我建议的单例实操，依然上代码：

```java
/**
 * @Author: darrylsun
 * @Description: 单例模式，内部类
 * @Date: 2023/07/23
 */
public class InnerClassSinglePattern {

    // 依然堵住该类被实例化的入口
    private InnerClassSinglePattern() {
        System.out.println("看看我被实例化了吗？？？");
    }

    // 内部类私有化实例我们的单例对象
    private static class HolderInstance {
        private static InnerClassSinglePattern instance = new InnerClassSinglePattern();
    }

    public static InnerClassSinglePattern getInstance() {
        return HolderInstance.instance;
    }

    public static String findJay() {
        return "find Jay Chou again and again";
    }

    public static void main(String[] args) {
        /**
         * 输出结果：
         * find Jay Chou again and again
         */
        System.out.println(InnerClassSinglePattern.findJay());

        // 获取单例实例
        // System.out.println(InnerClassSinglePattern.getInstance());
    }
}
```

通过静态内部类能很好的保证我们单例对象轻易的保证线程安全问题的同时，又可以让开发者可控的时机操作对象的实例化。

写到这里，想必通过以上三个单例代码的了解，已经对单例模式有了更清晰的认识吧，但这还远没有结束，单例模式的解读仅仅只是开始，后面会引发出一堆的问题等着我们一起去解密的哟！

## 二、单例引发的类加载的思考

书接上回，单例模式中饿汉模式，之所以叫饿汉就是因为不管我们的应用服务需不需要这个对象的实例，饿汉模式都会在应用服务启动时将这个对象实例化，从而保证了这个对象单例的特性。其中就涉及到我们接下来想聊的一个问题`java`中的类加载问题，先看一个基础知识的问题哈，然后很直观的感受下类加载的过程。

```java
/**
 * @Author: darrylsun
 * @Description: 一个 person 类
 * @Date: 2023/07/23
 */
public class Person {

    static {
        System.out.println("person static block");
    }

    public Person(String name) {
        System.out.println("person name is " + name);
    }

}

/**
 * @Author: darrylsun
 * @Description: 一个测试子类，继承测试父类
 * @Date: 2023/07/23
 */
public class TestClassLoaderChild extends TestClassLoader {

    Person person = new Person("TestClassLoaderChild");

    static {
        System.out.println("this is TestClassLoaderChild's static block");
    }

    public TestClassLoaderChild() {
        System.out.println("TestClassLoaderChild contractor");
    }
}

/**
 * @Author: darrylsun
 * @Description: 测试父类，并有 main 方法执行入口
 * @Date: 2023/07/23
 */
public class TestClassLoader {

    Person person = new Person("TestClassLoader");

    static {
        System.out.println("this is TestClassLoader static block");
    }

    public TestClassLoader() {
        System.out.println("TestClassLoader constructor");
    }

    public static void main(String[] args) {
        /**
         * 数据结果：
         * 1。首先要加载 TestClassLoader 类，类初始化，所以先输出 TestClassLoader 静态代码块的内容：this is TestClassLoader static block
         * 2。接着执行 new TestClassLoaderChild，因为其父类已经被加载过了，仅先需要先对 TestClassLoaderChild 进行类加载，加载过程中初始化，执行静态代码块内容：this is TestClassLoaderChild's static block
         * 3。初始化完成后就要生成对象，生成对象实例化前需要先对父类的成员变量实例化，即 new Person，则需要加载 person，初始化执行其静态代码块内容：person static block
         * 4。接着就要完成成员变量的构造函数完成对象的实例化，即输出内容：person name is TestClassLoader
         * 5。然后就可以执行父类的构造函数完成父类对象的实例的构建，即输出内容：TestClassLoader constructor
         * 6。此时父类已完成了全部的加载，继续对 child 类完成实例化，会先完成其成员变量的实例化，因为 person已经被初始化过了，即可直接执行构造函数输出内容：person name is TestClassLoaderChild
         * 7。然后对 child 类执行构造函数完成类加载的实例化，即输出内容：TestClassLoaderChild contractor
         */
        new TestClassLoaderChild();
    }
}
```

上面的代码中我们可以很直观的感受到一个类加载的过程中，比如需要`new`一个类时，先对其类进行加载，首当其冲的执行静态代码块，如果有父类同样需要先初始化父类的对象实例，紧接着完成对象中的成员变量的初始化，最后完成类本身的构造函数。大体上就是这样的一个执行顺序，那么为什么会是这样的呢？不知道有没有思考过呢？

这里我们先说下类加载的时机，划重点咯。

一个类从被加载的`JVM`虚拟机内存后，到被`JVM`卸载的整个生命周期，大体上有这么几个步骤：加载 ---> 验证 ---> 准备 ---> 解析 ---> 初始化 ---> 使用 ---> 卸载。那么一个类的加载时机到底是什么呢？

`JVM`对类【初始化】过程的时机有明确的规定：

（1）遇见`new`，`putstatic`等字节码指令时，如果类未初始化，就需要加载初始化；

（2）`JVM`虚拟机启动时，需要指定一个包含`main`函数的主类，并对其进行初始化；

（3）类被反射调用时，如果还没初始化，需要被初始化；

（4）初始化一个类时，如果其父类还没有被初始化，需要先初始化其父类；

（5）动态调用一个类的方法句柄时，遇见`REF_putstatic`时，这个方法句柄对应的类没有被初始化时就需要进行初始化；

除了以上五种场景外，都不会对类进行初始化；

【准备】阶段中，会对类的静态成员变量进行分配内存并设置初始值（如0，null, false等），这些变量（这里的变量仅是静态成员变量）所使用的内存在`JVM`的方法区中进行分配。

【初始化】阶段中，是执行类构造器 `<clinit>()` 方法的过程，`<clinit>()`方法会对类的静态成员变量和静态代码块进行执行操作，当然他不是必须的，如果一个类即没有静态代码块，也没有静态成员变量，这个类便不会有`<clinit>()`方法。`<clinit>()` 方法不需要显式调用父类构造器，虚拟机会保证在子类的 `<clinit>()` 方法执行之前，父类的 `<clinit>()` 方法已经执行完毕。由于父类的 `<clinit>()` 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作，这也就是上面的例子中为什么会输出父类的静态代码块内容的。那静态代码块与静态代码块之间的执行顺序，或者静态代码块和静态成员变量之间的执行顺序，完全是依照本身在源文件中的顺序进行执行的。

类加载过程中几个重要的阶段都已经解读完了，最后简单了解下其他阶段都做了什么吧～

【加载】阶段：主要就是根据类的全限定名获取类的二进制流。

【验证】阶段：主要完成当前二进制流文件满足当前`JVM`的规范要求。

【解析】阶段：主要是将常量池内的符号引用替换为直接引用。

【使用】和【卸载】阶段就不用再多说了，分别就是对类对象的使用和使用完成后卸载回收。

至此，我们就梳理清楚了一个类加载过程到底都做了什么，为什么这么做了。那是不是这个蝴蝶效应就完了吗？没那么简单，再回头看看我们上面最初的那个问题，其中是`new`了一个`TestClassLoaderChild`的对象实例的哟，不单单是初始化了一个类的。

哎，再简单解释下初始化和实例化的区别吧，初始化仅仅只是对类级别的操作，如初始化类的静态成员变量，初始化类中的静态代码块和描述定义类的信息保存在内存中，和类的实例无关。

类的实例化则是创建这个类的具体的实例，为这个类实例分配内存空间，并将对象的引用保存在内存中等，会执行类的构造函数和对实例变量进行初始化，实例化是对类的实例级别的操作，与类本身无关。

好了，那么`new TestClassLoaderChild()`对类实例化到底又做了什么呢？这可能就要说说`JVM`的内存结构这个重头戏咯。

## 三、类加载引发的`JVM`内存结构思考

一个对象被实例化后到底放哪了呢？在应用程序中他又何去何从呢，接下来我们就来细聊下`JVM`的内存结构。`JVM`内存结构主要规定了`java`进程在虚拟机上运行是对内存的申请，分配和管理的规则。`JVM`主要分为5部分：

1. 程序计数器
2. 栈
3. 本地方法栈
4. 堆
5. 方法区

![jvm_001](https://github.com/bboysun/DOC_CENTER/raw/master/image/jvm_001.png)

前三个是线程独有的，后两个是线程共享的。接下来我们就逐一的了解学习下吧。

### 程序计数器

**程序计数器** 是一块很小的内存空间，主要用来控制程序执行的流程控制，用于记录当前程序执行到哪一行对应的字节码。程序计数器是线程私有的，这样在多线程并发执行过程中，线程来回切换后也能知道当前线程具体执行的位置，然后就能接着继续执行了，生命周期同线程保持一致。

### 本地方法栈

**本地方法栈** 本地方法栈是`JVM`用于管理`java`程序调用本地方法（`native method`），本地方法都是用`C`语言写的，方便JVM`能更好的和外界环境交互，或者和操作系统间的交互，他同样是线程私有的。

### 虚拟机栈

**栈** 也叫`JVM`虚拟机栈，名字上主要和本地方法栈区分而已。虚拟机栈主要用于管理`java`程序的运行，包括局部变量，中间结果，方法调用（压栈）和方法结果返回（出栈）。虚拟机栈的存储单位到底是什么呢？每个线程都有自己的虚拟机栈，线程会将每个即将执行的`java`方法创建分配一块栈帧的内存区域。在一个时间点，只有有一个栈帧是有效的，即栈顶栈帧也叫当前栈帧。如果该方法内调用了其他方法，那么会将新的方法压栈到栈顶作为当前栈帧进行执行。当前栈帧执行完成后有返回结果会穿回前一个栈帧，当前栈帧会出栈，前一个栈帧则成为当前栈帧。方法的正常退出（即执行`return`）或者异常退出（`throw exception`）都会使得当前栈帧出栈。

了解了栈的运行原理后，那么我们放大一个栈帧再看看，栈帧中到底都存些什么东西。

一块栈帧中主要会保存的信息有：

1. 局部变量表
2. 操作数栈
3. 动态连接
4. 方法返回地址
5. 一些附加信息

![](https://github.com/bboysun/DOC_CENTER/raw/master/image/statck_info_3.png)

在简单说明栈帧中存储的信息时，可以类比的想一想我们平时写的一个方法，是不是都有些许影子。

**局部变量表** 是一组变量值的存储空间，主要存储了方法内定义的局部变量（有基本数据类型：`boolean byte char short int long double float`, 还有对象引用），方法参数以及方法返回`return address`类型。局部变量表所属的栈是线程私有的所以不会有线程安全的问题。局部变量表大存储大小和对应的方法参数等都有关系，如果一个方法对应的局部变量表越大，那么这个方法在同一个线程的栈中能够被调用的次数就越小。局部变量表只会在当前方法调用过程中有效，随着当前方法执行完成，当前栈帧也就随之销毁，栈帧中的局部变量表也会随之销毁。局部变量表也会作为垃圾回收的根结点，但凡一个对象直接或者间接被局部变量表引用，那么这个对象就不能被回收。

局部变量表是以`slot`为单位存储的，32位以内的类型都是有1个`slot`进行存储，64位的类型则是用2个连续的`slot`进行存储。如果当前栈帧对应到类的构造函数或者一个类的具体实例方法，那么这个对象实例的`this`会放到`index`为0的`slot`中，这也就是为什么我们在构造函数中可以使用`this`这个关键字，而在`static`方法中的局部变量表中不含有`this`变量，所以静态方法就无法使用`this`关键字。当然局部变量表中的`slot`是可以复用的，一个局部变量过了其作用域后，后续再申请的局部变量是可以申请到之前释放的`slot`进行变量存储的。

**操作数栈** 是一个先进后出的栈，也称为表达式栈，主要对方法内部的一些局部变量作入栈和出栈操作，通过入栈暂存变量，然后再在合适的时机出栈取出，进行表达式逻辑计算后，再将结果入栈为后续操作使用，如此反复来完成一个复杂的表达式逻辑。如果当前栈帧对应的方法有返回值的话，那么返回值最终就会被压入操作数栈中。

**动态连接**  是指向常量池中该栈帧对应方法的一个引用。可以理解为类`class B`的方法`methond B`中调用类`class A`的方法`method A`时，就是通过常量池中的这个引用找到对应的方法。`java`源文件被编译成字节码文件后，都是以符号引用保存在class文件的常量池中的，也就是说动态连接是为了将符号引用转换为真正的被调方法的直接引用而存在的。

![](https://github.com/bboysun/DOC_CENTER/raw/master/image/stack_info2.png)

一切方法调用在`class`文件中都是符号引用，而方法在实际运行过程中被调用时使用的是方法的直接引用，直接引用在类加载，甚至运行时才能确定该方法的直接引用。

如此一来，就有了静态链接：就是被调用方法在编译期可知且不可变更，那么便直接将该方法的符号引用转换为直接引用。这些方法对应称为非虚方法（如静态方法，私有方法，构造函数，`final`修饰的方法，父类的方法）。另外就是动态链接：就是只能在程序运行期间将方法的符号引用转换为直接引用，这些方法对应的称为虚方法（如一个类中定义的公有方法等）

**方法返回地址** 用来存放该方法程序计数器中的值。一般正常退出该方法，当前栈帧就是要出栈，出栈就要恢复下一个栈帧（即上一层方法）所需的局部变量表，操作数栈，将当前栈帧结果压入调用栈帧的操作数栈中，设置程序计数器指针（即调用该方法结束后需要执行的上层方法的执行指令的位置）。异常退出时，返回地址要通过异常表来确定，通过异常退出的栈帧不会给上层方法返回任何值。

**附加信息** 栈帧中还存有其他信息对程序调试运行提供支持。

### 堆

在`JVM`的世界中，几乎所有的对象的实例都是存储在堆内存空间中的，堆是`JVM`内存中最大的内存空间。`JVM`虚拟机的堆空间大致如下图所示：

![](https://github.com/bboysun/DOC_CENTER/raw/master/image/heap001.png)

`JVM`虚拟机对内存空间大致分为新生代（`Young Gen`）和老年代（`Old Gen`），注意在`JDK`8以后使用元空间替代了原来的老年代，元空间的概念主要还是在方法区中会提到，这里就不再赘述元空间了（至于为什么要用元空间替换原来永久代也是很多人的疑惑，我们放到后面再细嗦）。

如上图所示，新生代又被分成了三块，`Eden`，`Survivor0`和`Survivor1`他们默认的比例是8:1:1。可用通过`-Xmn`参数指定新生代空间的大小。

`Eden`（伊甸园很梦幻的名字，和这个区域的内存的意义很体贴），主要是用来存储新创建的对象实例。当`Eden`区的内存被填满时就会触发`Minor GC`，`Minor GC`执行时会将`Eden`区域幸存下来的对象，全部已到一个幸存区`Survivor`，同时还会将另一个幸存区的幸存者对象也移动到一个幸存区中，也就是每次都会有一个幸存空间是空的留着下次`Minor GC`时用。经过多次这样反复的`Minor GC`幸存下来的对象就会移动到老年代中（这里通过设置年轻代幸存对象的年龄的阈值作为依据，也就是`Minor GC`的次数）。

这样我们就能再丰富下`JVM`虚拟机对内存图咯

![](https://github.com/bboysun/DOC_CENTER/raw/master/image/heap002.png)

经过新生代反复幸存下来的对象我们认为这些对象应该会被长时间存活下来，那就将这些存活下来的幸存者对象移动到老年代，另外如果新建的大对象一般也会直接进入老年代，这样就避免这些大对象在新生代中来回进行复制拷贝。`JVM`给了新生代的参数去声明新生代空间大小，那么老年代有参数声明吗？对不起，没有。不过没关系，`JVM`给了参数（`-Xmx`最大堆内存，`-Xms`最小堆内存）去声明整个内存堆空间的大小，那么两个相减自然就得到老年代内存大小咯。

一般老年代内存满的时候就会在老年代触发`Major GC`，一般`Major GC`的耗时会比`Minor GC`要长，另外在触发`Major GC`前也都会先触发一次`Minor GC`。

这里有几个GC（`Minor GC`，`Major GC`，`Full GC`）的概念让人很困惑，他们到底是什么关系？

`Minor GC`主要用于新生代内存空间的垃圾回收。

`Major GC`主要用于老年代内存空间的垃圾回收，一般执行前会先触发`Minor GC`，这样就是整个`Java`虚拟机内存空间上的垃圾回收了。

`Full GC`主要是一个笼统的概念，就是对整个`Java`虚拟机对内存空间和方法区内存空间进行垃圾回收。

理清上面的概念后，我们其实可以简单的认为，`Full GC`就等价于`Major GC`，因为目前常用的垃圾回收器的算法（`CMS`，`G1`的实现逻辑在`Full GC`和`Major GC`都是模糊混合的实现），其实少一点模糊的概念会让我们更简单的清晰的理解。那我们就按常说的`Full GC`去理解吧。

这样一来，我们最后完善下堆内存图如下：

![](https://github.com/bboysun/DOC_CENTER/raw/master/image/heap003.png)

最后我们给个栗子来获取你本地机器运行时的`Java`进程所占用的堆内存的参数配置，这样我们就可以自己写一个`OOM`的`DEMO`，或者通过不断的构建对象来模拟对象在`JVM`内存结构中是如何走位的哈。

```java
/**
 * @Author: darrylsun
 * @Description: 获取当前运行java进程的初始化对内存大小
 * @Date: 2023/07/29
 */
public class Testheap {

    public static void main(String[] args) {
        //返回 JVM 堆大小
        long initalMemory = Runtime.getRuntime().totalMemory() / 1024 /1024;
        //返回 JVM 堆的最大内存
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 /1024;

        System.out.println("-Xms : "+initalMemory + "M");
        System.out.println("-Xmx : "+maxMemory + "M");

    }
}
```

这里留个坑，我们也会专门出一篇文章解读`JVM`参数时，回过头来填坑。

到这里我们简单就将堆内存结构介绍清楚了，最后我们再耐下心来看看最后的方法区到底又是什么吧。

### 方法区

To be continue...
