# 一个单例的蝴蝶效应

## 一、蝴蝶挥了挥翅膀

设计模式想必大家应该都不陌生的吧，在我们日常工作中时常都会碰到或者用到，大体分为三类：创建型模式，结构型模式和行为型模式；今天我们不是讲所有的设计模式的，今天只是想从一个设计模式入手，看看他到底如何扇扇一翅膀如何能在大洋彼岸刮起一场飓风的。

就从我们耳熟能详，也是用的最多错的最多的单例模式入手吧！！！

单例模式是我们常见的一种创建型模式，简单概括下创建型模式，创建型模式说白了就是创建一个又一个的对象，我们最熟悉的就是不停的 `new` 一个对象，但往往我们需要更友好，更易扩展，更有特性的创建方式，于是在各种诉求中就有一个特性的`case`，需要我们在整个应用程序中有且仅有一个对象的实例，这就是我们所说的单例模式。

单例我们经常知道的比如饿汉模式，直接上代码说明，代码中有明确的注释，一定要看注释哟！！！

```java
/**
 * @Author: darrylsun
 * @Description: 单例模式--饿汉模式
 * @Date: 2023/07/22
 */
public class SinglePattern {

    // 私有化构造函数，堵住其他地方创建实例的入口
    private SinglePattern() {
        System.out.println("我被实例化了");
    }

    // 创建私有的静态实例，类加载过程中已经被创建
    // 初始化的顺序无法确定，如果该类依赖于其他类的初始化，那就会有问题！！！
    private static SinglePattern instance = new SinglePattern();

    // 静态方法获取唯一的实例，这样我们就构建好了一个单例
    public static SinglePattern getInstance() {
        return instance;
    }

    // 假设这里有一个静态方法，开发者仅仅只是想调用该方法不想实例化这个对象占用空间，不好意思，这个类已经被实例化了！！！
    public static String findJay() {
        return "find Jay Chou";
    }


    public static void main(String[] args) {
        /**
         * 输出结果：
         * 我被实例化了
         * find Jay Chou
         */
        System.out.println(SinglePattern.findJay());

        // 获取单例实例
        // System.out.println(SinglePattern.getInstance());
    }
}
```

此时，饿汉模式的单例挥动的翅膀，已经为我们引发了下一个问题【类加载】的问题，我们后面再说，先把单例的两种模式都说完哈～～～

接着我们再说说懒汉模式，还是一如既往的直接看代码，还是老规矩，一定要看注释哟！！！

```java
/**
 * @Author: darrylsun
 * @Description: 单例 懒汉模式
 * @Date: 2023/07/22
 */
public class LazySinglePattern {

    // 依然堵住被随意创建对象的入口，私有化构造函数
    private LazySinglePattern() {
        System.out.println("我又被初始化了");
    }

    // 声明我们需要的单例实例化对象，这里需要留意 volatile 关键字哟！！！
    private static volatile LazySinglePattern instance;

    // 双重锁校验，保证多线程环境中单例的线程安全问题！！！
    public static LazySinglePattern getInstance() {
        if (instance == null) {
            synchronized (LazySinglePattern.class) {
                if (instance == null) {
                    instance = new LazySinglePattern();
                }
            }
        }
        return instance;
    }

    public static String fingJay() {
        return "find Jay Chou again";
    }

    public static void main(String[] args) {
        /**
         * 输出结果：
         * find Jay Chou again
         */
        System.out.println(LazySinglePattern.fingJay());

        // 获取单例实例
        // System.out.println(LazySinglePattern.getInstance());
    }
}
```

此时懒汉模式的单例也已经挥动了自己的翅膀，为我们带来了一个很重要的关键字`volatile`和`synchronized`，因为懒汉模式是在我们需要的时候的才会创建对象实例，这样就需要我们自己来保证单例对象在多线程环境下的线程安全问题。至于这两个关键字我们还是放到后面慢慢品尝。

第一章节内容的最后，我还是给出日常开发过程中我建议的单例实操，依然上代码：

```java
/**
 * @Author: darrylsun
 * @Description: 单例模式，内部类
 * @Date: 2023/07/23
 */
public class InnerClassSinglePattern {

    // 依然堵住该类被实例化的入口
    private InnerClassSinglePattern() {
        System.out.println("看看我被实例化了吗？？？");
    }

    // 内部类私有化实例我们的单例对象
    private static class HolderInstance {
        private static InnerClassSinglePattern instance = new InnerClassSinglePattern();
    }

    public static InnerClassSinglePattern getInstance() {
        return HolderInstance.instance;
    }

    public static String findJay() {
        return "find Jay Chou again and again";
    }

    public static void main(String[] args) {
        /**
         * 输出结果：
         * find Jay Chou again and again
         */
        System.out.println(InnerClassSinglePattern.findJay());

        // 获取单例实例
        // System.out.println(InnerClassSinglePattern.getInstance());
    }
}
```

通过静态内部类能很好的保证我们单例对象轻易的保证线程安全问题的同时，又可以让开发者可控的时机操作对象的实例化。

写到这里，想必通过以上三个单例代码的了解，已经对单例模式有了更清晰的认识吧，但这还远没有结束，单例模式的解读仅仅只是开始，后面会引发出一堆的问题等着我们一起去解密的哟！

## 二、单例引发的类加载的思考

书接上回，单例模式中饿汉模式，之所以叫饿汉就是因为不管我们的应用服务需不需要这个对象的实例，饿汉模式都会在应用服务启动时将这个对象实例化，从而保证了这个对象单例的特性。其中就涉及到我们接下来想聊的一个问题`java`中的类加载问题，先看一个基础知识的问题哈，然后很直观的感受下类加载的过程。

```java
/**
 * @Author: darrylsun
 * @Description: 一个 person 类
 * @Date: 2023/07/23
 */
public class Person {

    static {
        System.out.println("person static block");
    }

    public Person(String name) {
        System.out.println("person name is " + name);
    }

}

/**
 * @Author: darrylsun
 * @Description: 一个测试子类，继承测试父类
 * @Date: 2023/07/23
 */
public class TestClassLoaderChild extends TestClassLoader {

    Person person = new Person("TestClassLoaderChild");

    static {
        System.out.println("this is TestClassLoaderChild's static block");
    }

    public TestClassLoaderChild() {
        System.out.println("TestClassLoaderChild contractor");
    }
}

/**
 * @Author: darrylsun
 * @Description: 测试父类，并有 main 方法执行入口
 * @Date: 2023/07/23
 */
public class TestClassLoader {

    Person person = new Person("TestClassLoader");

    static {
        System.out.println("this is TestClassLoader static block");
    }

    public TestClassLoader() {
        System.out.println("TestClassLoader constructor");
    }

    public static void main(String[] args) {
        /**
         * 数据结果：
         * 1。首先要加载 TestClassLoader 类，类初始化，所以先输出 TestClassLoader 静态代码块的内容：this is TestClassLoader static block
         * 2。接着执行 new TestClassLoaderChild，因为其父类已经被加载过了，仅先需要先对 TestClassLoaderChild 进行类加载，加载过程中初始化，执行静态代码块内容：this is TestClassLoaderChild's static block
         * 3。初始化完成后就要生成对象，生成对象实例化前需要先对父类的成员变量实例化，即 new Person，则需要加载 person，初始化执行其静态代码块内容：person static block
         * 4。接着就要完成成员变量的构造函数完成对象的实例化，即输出内容：person name is TestClassLoader
         * 5。然后就可以执行父类的构造函数完成父类对象的实例的构建，即输出内容：TestClassLoader constructor
         * 6。此时父类已完成了全部的加载，继续对 child 类完成实例化，会先完成其成员变量的实例化，因为 person已经被初始化过了，即可直接执行构造函数输出内容：person name is TestClassLoaderChild
         * 7。然后对 child 类执行构造函数完成类加载的实例化，即输出内容：TestClassLoaderChild contractor
         */
        new TestClassLoaderChild();
    }
}
```

上面的代码中我们可以很直观的感受到一个类加载的过程中，比如需要`new`一个类时，先对其类进行加载，首当其冲的执行静态代码块，如果有父类同样需要先初始化父类的对象实例，紧接着完成对象中的成员变量的初始化，最后完成类本身的构造函数。大体上就是这样的一个执行顺序，那么为什么会是这样的呢？不知道有没有思考过呢？

这里我们先说下类加载的时机，划重点咯。

一个类从被加载的`JVM`虚拟机内存后，到被`JVM`卸载的整个生命周期，大体上有这么几个步骤：加载 ---> 验证 ---> 准备 ---> 解析 ---> 初始化 ---> 使用 ---> 卸载。那么一个类的加载时机到底是什么呢？

`JVM`对类【初始化】过程的时机有明确的规定：

（1）遇见`new`，`putstatic`等字节码指令时，如果类未初始化，就需要加载初始化；

（2）`JVM`虚拟机启动时，需要指定一个包含`main`函数的主类，并对其进行初始化；

（3）类被反射调用时，如果还没初始化，需要被初始化；

（4）初始化一个类时，如果其父类还没有被初始化，需要先初始化其父类；

（5）动态调用一个类的方法句柄时，遇见`REF_putstatic`时，这个方法句柄对应的类没有被初始化时就需要进行初始化；

除了以上五种场景外，都不会对类进行初始化；

【准备】阶段中，会对类的静态成员变量进行分配内存并设置初始值（如0，null, false等），这些变量（这里的变量仅是静态成员变量）所使用的内存在`JVM`的方法区中进行分配。

【初始化】阶段中，是执行类构造器 `<clinit>()` 方法的过程，`<clinit>()`方法会对类的静态成员变量和静态代码块进行执行操作，当然他不是必须的，如果一个类即没有静态代码块，也没有静态成员变量，这个类便不会有`<clinit>()`方法。`<clinit>()` 方法不需要显式调用父类构造器，虚拟机会保证在子类的 `<clinit>()` 方法执行之前，父类的 `<clinit>()` 方法已经执行完毕。由于父类的 `<clinit>()` 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作，这也就是上面的例子中为什么会输出父类的静态代码块内容的。那静态代码块与静态代码块之间的执行顺序，或者静态代码块和静态成员变量之间的执行顺序，完全是依照本身在源文件中的顺序进行执行的。

类加载过程中几个重要的阶段都已经解读完了，最后简单了解下其他阶段都做了什么吧～

【加载】阶段：主要就是根据类的全限定名获取类的二进制流。

【验证】阶段：主要完成当前二进制流文件满足当前`JVM`的规范要求。

【解析】阶段：主要是将常量池内的符号引用替换为直接引用。

【使用】和【卸载】阶段就不用再多说了，分别就是对类对象的使用和使用完成后卸载回收。

至此，我们就梳理清楚了一个类加载过程到底都做了什么，为什么这么做了。那是不是这个蝴蝶效应就完了吗？没那么简单，再回头看看我们上面最初的那个问题，其中是`new`了一个`TestClassLoaderChild`的对象实例的哟，不单单是初始化了一个类的。

哎，再简单解释下初始化和实例化的区别吧，初始化仅仅只是对类级别的操作，如初始化类的静态成员变量，初始化类中的静态代码块和描述定义类的信息保存在内存中，和类的实例无关。

类的实例化则是创建这个类的具体的实例，为这个类实例分配内存空间，并将对象的引用保存在内存中等，会执行类的构造函数和对实例变量进行初始化，实例化是对类的实例级别的操作，与类本身无关。

好了，那么`new TestClassLoaderChild()`对类实例化到底又做了什么呢？这可能就要说说`JVM`的内存结构这个重头戏咯。

三、`JVM`内存结构

一个对象被实例化后到底放哪了呢？在应用程序中他又何去何从呢，接下来我们就来细聊下`JVM`的内存结构。`JVM`内存结构主要规定了`java`进程在虚拟机上运行是对内存的申请，分配和管理的规则。`JVM`主要分为5部分：

1. 程序计数器
2. 栈
3. 本地方法栈
4. 堆
5. 方法区

![jvm_001](https://github.com/bboysun/DOC_CENTER/raw/master/image/jvm_001.png)

前三个是线程独有的，后两个是线程共享的。接下来我们就逐一的了解学习下吧。

**程序计数器** 是一块很小的内存空间，主要用来控制程序执行的流程控制，用于记录当前程序执行到哪一行对应的字节码。程序计数器是线程私有的，这样在多线程并发执行过程中，线程来回切换后也能知道当前线程具体执行的位置，然后就能接着继续执行了，生命周期同线程保持一致。

**本地方法栈** 本地方法栈是`JVM`用于管理`java`程序调用本地方法（`native method`），本地方法都是用`C`语言写的，方便JVM`能更好的和外界环境交互，或者和操作系统间的交互，他同样是线程私有的。

**栈** 也叫`JVM`虚拟机栈，名字上主要和本地方法栈区分而已。虚拟机栈主要用于管理`java`程序的运行，包括局部变量，中间结果，方法调用（压栈）和方法结果返回（出栈）。虚拟机栈的存储单位到底是什么呢？每个线程都有自己的虚拟机栈，线程会将每个即将执行的`java`方法创建分配一块栈帧的内存区域。在一个时间点，只有有一个栈帧是有效的，即栈顶栈帧也叫当前栈帧。如果该方法内调用了其他方法，那么会将新的方法压栈到栈顶作为当前栈帧进行执行。当前栈帧执行完成后有返回结果会穿回前一个栈帧，当前栈帧会出栈，前一个栈帧则成为当前栈帧。方法的正常退出（即执行`return`）或者异常退出（`throw exception`）都会使得当前栈帧出栈。

了解了栈的运行原理后，那么我们放大一个栈帧再看看，栈帧中到底都存些什么东西。

to be contine...







