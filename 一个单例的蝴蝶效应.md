# 一个单例的蝴蝶效应

## 一、蝴蝶挥了挥翅膀

设计模式想必大家应该都不陌生的吧，在我们日常工作中时常都会碰到或者用到，大体分为三类：创建型模式，结构型模式和行为型模式；今天我们不是讲所有的设计模式的，今天只是想从一个设计模式入手，看看他到底如何扇扇一翅膀如何能在大洋彼岸刮起一场飓风的。

就从我们耳熟能详，也是用的最多错的最多的单例模式入手吧！！！

单例模式是我们常见的一种创建型模式，简单概括下创建型模式，创建型模式说白了就是创建一个又一个的对象，我们最熟悉的就是不停的 `new` 一个对象，但往往我们需要更友好，更易扩展，更有特性的创建方式，于是在各种诉求中就有一个特性的`case`，需要我们在整个应用程序中有且仅有一个对象的实例，这就是我们所说的单例模式。

单例我们经常知道的比如饿汉模式，直接上代码说明，代码中有明确的注释，一定要看注释哟！！！

```java
/**
 * @Author: darrylsun
 * @Description: 单例模式--饿汉模式
 * @Date: 2023/07/22
 */
public class SinglePattern {

    // 私有化构造函数，堵住其他地方创建实例的入口
    private SinglePattern() {
        System.out.println("我被实例化了");
    }

    // 创建私有的静态实例，类加载过程中已经被创建
    // 初始化的顺序无法确定，如果该类依赖于其他类的初始化，那就会有问题！！！
    private static SinglePattern instance = new SinglePattern();

    // 静态方法获取唯一的实例，这样我们就构建好了一个单例
    public static SinglePattern getInstance() {
        return instance;
    }

    // 假设这里有一个静态方法，开发者仅仅只是想调用该方法不想实例化这个对象占用空间，不好意思，这个类已经被实例化了！！！
    public static String findJay() {
        return "find Jay Chou";
    }


    public static void main(String[] args) {
        /**
         * 输出结果：
         * 我被实例化了
         * find Jay Chou
         */
        System.out.println(SinglePattern.findJay());

        // 获取单例实例
        // System.out.println(SinglePattern.getInstance());
    }
}
```

此时，饿汉模式的单例挥动的翅膀，已经为我们引发了下一个问题【类加载】的问题，我们后面再说，先把单例的两种模式都说完哈～～～

接着我们再说说懒汉模式，还是一如既往的直接看代码，还是老规矩，一定要看注释哟！！！

```java
/**
 * @Author: darrylsun
 * @Description: 单例 懒汉模式
 * @Date: 2023/07/22
 */
public class LazySinglePattern {

    // 依然堵住被随意创建对象的入口，私有化构造函数
    private LazySinglePattern() {
        System.out.println("我又被初始化了");
    }

    // 声明我们需要的单例实例化对象，这里需要留意 volatile 关键字哟！！！
    private static volatile LazySinglePattern instance;

    // 双重锁校验，保证多线程环境中单例的线程安全问题！！！
    public static LazySinglePattern getInstance() {
        if (instance == null) {
            synchronized (LazySinglePattern.class) {
                if (instance == null) {
                    instance = new LazySinglePattern();
                }
            }
        }
        return instance;
    }

    public static String fingJay() {
        return "find Jay Chou again";
    }

    public static void main(String[] args) {
        /**
         * 输出结果：
         * find Jay Chou again
         */
        System.out.println(LazySinglePattern.fingJay());

        // 获取单例实例
        // System.out.println(LazySinglePattern.getInstance());
    }
}
```

此时懒汉模式的单例也已经挥动了自己的翅膀，为我们带来了一个很重要的关键字`volatile`和`synchronized`，因为懒汉模式是在我们需要的时候的才会创建对象实例，这样就需要我们自己来保证单例对象在多线程环境下的线程安全问题。至于这两个关键字我们还是放到后面慢慢品尝。

第一章节内容的最后，我还是给出日常开发过程中我建议的单例实操，依然上代码：

```java
/**
 * @Author: darrylsun
 * @Description: 单例模式，内部类
 * @Date: 2023/07/23
 */
public class InnerClassSinglePattern {

    // 依然堵住该类被实例化的入口
    private InnerClassSinglePattern() {
        System.out.println("看看我被实例化了吗？？？");
    }

    // 内部类私有化实例我们的单例对象
    private static class HolderInstance {
        private static InnerClassSinglePattern instance = new InnerClassSinglePattern();
    }

    public static InnerClassSinglePattern getInstance() {
        return HolderInstance.instance;
    }

    public static String findJay() {
        return "find Jay Chou again and again";
    }

    public static void main(String[] args) {
        /**
         * 输出结果：
         * find Jay Chou again and again
         */
        System.out.println(InnerClassSinglePattern.findJay());

        // 获取单例实例
        // System.out.println(InnerClassSinglePattern.getInstance());
    }
}
```

通过静态内部类能很好的保证我们单例对象轻易的保证线程安全问题的同时，又可以让开发者可控的时机操作对象的实例化。

写到这里，想必通过以上三个单例代码的了解，已经对单例模式有了更清晰的认识吧，但这还远没有结束，单例模式的解读仅仅只是开始，后面会引发出一堆的问题等着我们一起去解密的哟！

## 二、单例引发的类加载的思考

To be continue...

