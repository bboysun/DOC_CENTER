## 秒杀系统的关键点

简单说下我对设计一个秒杀系统的关键点的理解。这里只概括的说下思路和方案。

秒杀系统的特点：醉醉关键的就是不能多扣库存，本来已经被秒杀完的商品，还有其他用户能够请到下单付款，那就麻烦大了。

**关键点1：通过乐观锁控制不会多卖**，至于什么乐观锁，这里就不细说，可以用数据库的版本号控制，每次更新操作都要带上版本号的值，如果值一致则更新，如果不一致就报错，用户可以自行catch这个异常进行处理。

**关键点2：如何提高吞吐量**，我们可以选择部署多个应用实例，通过NGINX反向代理upstream去完成多个多个应用实例的负载均衡，负载均衡的策略也有很多，常用的轮询，加权重值，请求的IP做hash取模，请求的方法做hash取模等方法。说到hash，那不得不提的就是hash一致性的问题，这个问题简单说将我们的应用实例对2的32次方取模分别得到一个值A，每次请求过来的IP再对2的32次取模运算得到的值B，值B顺时针方向最近的应用实例就是他要访问的应用服务。

**关键点3：请求数量远远大于商品数量，那就要做分布式限流不浪费资源**，我们可以通过redis + lua去做分布式限流，redis的自增计数配合lua脚本的原子性控制，lua脚本控制自增计数大于某一个值的时候返回0，小于某个值的时候就持续自增，同时记得要给这个自增计数添加过期时间。通过这个限流器来节省资源。

**关键点4：怎样减轻数据库的压力**，减轻数据库压力没办法，就选用redis做缓存，每次查询就从缓存中查询，更新删除时同步对缓存更新删除，这里需要注意的就是缓存和DB库的双写一致性问题。简单说，查询数据，先走缓存，缓存没有再查DB，从DB中查出来同步到缓存中。更新数据，先删除缓存，然后再更新DB。

**关键点5：对DB做异步处理**，可以选用KAFKA将对DB操作的请求同步转成异步处理，每当一个请求通过了限流到达了 Service 层通过了库存校验之后就将订单信息发给 Kafka ，这样一个请求就可以直接返回了。消费程序再对数据进行入库落地。因为异步了，所以最终需要采取回调或者是其他提醒的方式提醒用户购买完成。

后续可以通过简单的demo逐步实现以上的步骤。

