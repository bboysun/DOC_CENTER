## 初谈BitMap

#### 一、前言

bitmap又叫位图，是一种常见的数据结构，代表了有限域中的稠集（dense set），每个元素至少出现一次，没有其他的数据和元素相关联。在索引，数据压缩，海量数据处理等方面有广泛的应用。

#### 二、原理

bitmap基本是用一个bit位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存在不存在。

比如，在Java中一个int类型占4个字节，也就是32bit，通常情况是我们一个int类型仅仅表示一个整数，但其实如果映射成位存储的话，一个int类型是可以存储32个bit状态的。

再试想一下，1G换算成bit就是1024\*1024\*1024\*8约等于2亿6千万个int类型。面对海量数据时，如果采用了bit存储，那么存储空间方面可以大大节省。

Java中已经为我们实现了bitset数据结构，BitSet的底层使用的是long类型的数组来存储元素。long类型占8个字节，也就是64bit。

如果我们想要排序或者查找的总数N=10000，那么我们需要申请多大的数组呢？

用int类型：int temp[] = new int[1+N/32]，也就是313；

用long类型：long temp[] = new long[1+N/32]，也就是157；

注意java里面的整数除法是向下取整的，所以数组长度还需要加1；以int为例，生成的bitmap表如下：

```javascript
a[0]--------->0-31 ->bit表示[0000000000000000000000000000000000000]
a[1]--------->32-63 ->bit表示[0000000000000000000000000000000000000]
a[2]--------->64-95 ->bit表示[0000000000000000000000000000000000000]
```

我们实际上只是申请了一个int的一维数组，那么我们可以当成列为32位的二维数组；具体操作，先对32进行相除得到int数组的下标，然后十进制转成二进制之后，进行位运算，用来代表状态。

举个实际的例子，对不重复的数组进行排序；

```java
/**
 * @Author: darrylsun
 * @Description: bit map test
 * @Date: 2020/10/15
 */
public class BigSetTest {
    public static void main(String[] args) {
        int [] array = new int [] {1,2,3,22,0,389,63};
        BitSet bitSet  = new BitSet(1);
        System.out.println(bitSet.size());   //64
        bitSet  = new BitSet(65);
        System.out.println(bitSet.size());   //128
        bitSet  = new BitSet(23);
        System.out.println(bitSet.size());   //64

        //将数组内容组bitmap
        for(int i=0;i<array.length;i++)
        {
            bitSet.set(array[i], true);
        }

        System.out.println(bitSet.get(22));
        System.out.println(bitSet.get(60));

        System.out.println("下面开始遍历BitSet：");
        // 排序
        for ( int i = 0; i < bitSet.size(); i++ ){
            if (bitSet.get(i)) {
                System.out.println(i);
            }
        }
    }
}
```

结果输出：

```javascript
64
128
64
true
false
下面开始遍历BitSet：
0
1
2
3
22
63
389

Process finished with exit code 0
```

看到这里，如果熟悉排序算法里面计数排序，那么我们就能发现原理非常类似，不同的是使用bitmap排序占用的存储空间更小，但缺点是不支持重复数字。

#### 三、bitmap算法一些处理大数据问题的场景

（1）给定40亿个不重复的 int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中。

解法：遍历40亿数字，映射到BitMap中，然后对于给出的数，直接判断指定的位上存在不存在即可。

（2）使用位图法判断整形数组是否存在重复

解法：遍历一遍，存在之后设置成1，每次放之前先判断是否存在，如果存在，就代表该元素重复。

（3）使用位图法进行元素不重复的整形数组排序

解法：遍历一遍，设置状态1，然后再次遍历，对状态等于1的进行输出，参考计数排序的原理。

（4）在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数

解法1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）。

解法2：采用两个BitMap，即第一个Bitmap存储的是整数是否出现，接着，在之后的遍历先判断第一个BitMap里面是否出现过，如果出现就设置第二个BitMap对应的位置也为1，最后遍历BitMap，仅仅在一个BitMap中出现过的元素，就是不重复的整数。

解法3：分治+Hash取模，拆分成多个小文件，然后一个个文件读取，直到内存装的下，然后采用Hash+Count的方式判断即可。

该类问题的变形问题，如已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。 8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==12MBytes，这样，就用了小小的12M左右的内存表示了所有的8位数的电话）

#### 四、bitmap的缺点：

（1）数据碰撞。比如将字符串映射到 BitMap 的时候会有碰撞的问题，那就可以考虑用 Bloom Filter 来解决，Bloom Filter 使用多个 Hash 函数来减少冲突的概率。

（2）数据稀疏。又比如要存入(10,8887983,93452134)这三个数据，我们需要建立一个 99999999 长度的 BitMap ，但是实际上只存了3个数据，这时候就有很大的空间浪费，碰到这种问题的话，可以通过引入 Roaring BitMap 来解决。

#### 五、总结

本文主要介绍了BitMap算法的基本原理和应用案例，其本质上是采用了bit位来表示元素状态，从而在特定场景下能够极大的节省存储空间，非常适合对海量数据的查找，判重，删除等问题的处理。